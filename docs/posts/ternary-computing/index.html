<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Ternary Computing | Julien&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction First, let us define “computers” as any machine that can compute.
At first, analog machines were used. For example, electronic amplifiers can be used to perform integration, differentiation, root extraction, compute logarithm.
Analog computers played a significant role in history, but they have the disadvantage that noise can perturb the computation and lead to errors.
Digital computers later replaced analog ones and became mainstream. Any voltage within a range can be interpreted as a specific value.">
<meta name="author" content="Julien Seveno">
<link rel="canonical" href="https://bornlex.github.io/posts/ternary-computing/">
<meta name="google-site-verification" content="XYZabc">
<meta name="yandex-verification" content="XYZabc">
<meta name="msvalidate.01" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://bornlex.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="https://bornlex.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://bornlex.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://bornlex.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://bornlex.github.io/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous" />

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>
<meta property="og:title" content="Ternary Computing" />
<meta property="og:description" content="Introduction First, let us define “computers” as any machine that can compute.
At first, analog machines were used. For example, electronic amplifiers can be used to perform integration, differentiation, root extraction, compute logarithm.
Analog computers played a significant role in history, but they have the disadvantage that noise can perturb the computation and lead to errors.
Digital computers later replaced analog ones and became mainstream. Any voltage within a range can be interpreted as a specific value." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bornlex.github.io/posts/ternary-computing/" /><meta property="og:image" content="https://bornlex.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-31T15:21:00+01:00" />
<meta property="article:modified_time" content="2024-01-31T15:21:00+01:00" /><meta property="og:site_name" content="Julien&#39;s blog" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://bornlex.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"/>

<meta name="twitter:title" content="Ternary Computing"/>
<meta name="twitter:description" content="Introduction First, let us define “computers” as any machine that can compute.
At first, analog machines were used. For example, electronic amplifiers can be used to perform integration, differentiation, root extraction, compute logarithm.
Analog computers played a significant role in history, but they have the disadvantage that noise can perturb the computation and lead to errors.
Digital computers later replaced analog ones and became mainstream. Any voltage within a range can be interpreted as a specific value."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://bornlex.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Ternary Computing",
      "item": "https://bornlex.github.io/posts/ternary-computing/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Ternary Computing",
  "name": "Ternary Computing",
  "description": "Introduction First, let us define “computers” as any machine that can compute.\nAt first, analog machines were used. For example, electronic amplifiers can be used to perform integration, differentiation, root extraction, compute logarithm.\nAnalog computers played a significant role in history, but they have the disadvantage that noise can perturb the computation and lead to errors.\nDigital computers later replaced analog ones and became mainstream. Any voltage within a range can be interpreted as a specific value.",
  "keywords": [
    
  ],
  "articleBody": " Introduction First, let us define “computers” as any machine that can compute.\nAt first, analog machines were used. For example, electronic amplifiers can be used to perform integration, differentiation, root extraction, compute logarithm.\nAnalog computers played a significant role in history, but they have the disadvantage that noise can perturb the computation and lead to errors.\nDigital computers later replaced analog ones and became mainstream. Any voltage within a range can be interpreted as a specific value. This makes digital computers much more resilient to errors.\nWhy base 3? What is a numbering system? Today, there are two numbering systems:\ndecimal : used to represent numbers on a daily basis, count by hands binary : used by a (very) large majority of computers The general formula to encode a number looks like this: $$ x = \\sum_{i = 0}^N d_i r^i $$\nWhere:\n$d_i$ a factor for the $i\\text{-th}$ power $r$ is the base (for instance 2 for the binary system) Let us give some examples:\nin decimal (base 10), we read a number as follows: $$ 19 = 1 * 10^1 + 9 * 10^0 = 10 + 9 $$\nHere $r = 10$, $d_0 = 0$, $d_1 = 1$.\nin binary (base 2), the same number is represented as: $$ 19 = 1 * 2^4 + 0 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 16 + 2 + 1 = 10011 $$\nAs we can see with those examples, the binary system uses more digits than the decimal system. But the decimal system needs to be able to produce 10 different values, instead of just two for the binary system.\nWe could ask ourselves what is the best, most efficient numbering system. But how do you measure the cost of a numeric representation?\nIs there an optimized numbering system? You cannot simply count digits, because then the bigger the numbering system the better. For example, you could represent 542,978 on a base 1,000,000 system. This way, you would have only 1 digit. But you would also have to recognize 1,000,000 different values for each digit, which might not be that easy, nor reliable. On the other hand, nothing prevent you from using a base 1 system to store the value 542,978. You would only have to recognize if the digit value is 0 or 1, but you would need at least 542,978 digits to store the entire value, which does not seem very efficient.\nBy the way, this is why the base 2 system is convenient. It can represent any number using a relatively low numbers of digits, and recognizing if the value of the digit is 0 or 1 is easy, and components to build a computer using such a system are cheap.\nWhat we understand is that there is a tradeoff between the number of digits to use to store values and the values that each of the digits can take. Let us give names to those two things:\n$r$ is the base, the number of values per digit $w$ is the number of digits In order to optimize the numbering system, we want the base to be as low as possible as well as the number of digits to store a fixed value, for example 1,000,000. We can try to optimize the product of those two values:\n$$ r^* = \\argmin_{r, w} rw $$\nWith keeping the following value constant (which represents the maximum value that can be stored):\n$$ a = r^w $$\nWe can rewrite the second equation as:\n$$ w = \\frac{\\ln a}{\\ln r} $$\nAnd use this value in the first equation:\n$$ r^* = \\argmin_{r, w} \\text{ } rw \\Leftrightarrow \\argmin_r \\text{ } \\ln a \\frac{r}{\\ln r} $$\nThe term $\\ln a$ is constant, so we can discard it, it won’t change the minimum of the expression:\n$$ r^* = \\argmin_r \\frac{r}{\\ln r} $$\nWhich looks like this on a plot: The minimum of the function seems to reached between 2.5 and 3. The exact value is given by the following formula:\n$$ r^* = \\argmin_r \\frac{r}{\\ln r} \\Leftrightarrow (\\frac{r}{\\ln r})’ = 0 \\Leftrightarrow \\frac{1}{\\ln r} - \\frac{1}{(\\ln r)^2} $$\n$$ \\frac{1}{\\ln r} - \\frac{1}{(\\ln r)^2} \\Leftrightarrow \\frac{1}{\\ln r} = \\frac{1}{(\\ln r)^2} \\Leftrightarrow \\ln r = (\\ln r)^2 $$\nWhich is true for:\n$$ \\ln r = 1 \\Leftrightarrow r = e \\simeq 2.718 $$\nAssuming that we need to represent numbers from 0 to 999,999 we can compute the product $rw$ for different base values:\nbase 2 : $rw = 2 * \\frac{\\ln 999999}{\\ln 2} \\simeq 2 * 20 = 40$ base 10 : $rw = 10 * \\frac{\\ln 999999}{\\ln 10} \\simeq 10 * 6 = 60$ base $e$ : $rw = e * \\frac{\\ln 999999}{\\ln e} \\simeq e * 14 = 38.056$ base 3 : $rw = 3 * \\frac{\\ln 999999}{\\ln 3} \\simeq 3 * 13 = 39$ $e \\simeq 2.718$ is closer to three, which is confirmed by the value of the $rw$ product which is lower for base 3 than for base 2 or 10, making it the best system according to our hypothesis.\nThis is why at the early stages of computer science, the base 3 system attracted many computer designers.\nHistory The first working ternary computer ever built was in USSR during the cold war. A few dozens machines were built, but the ternary system faded away gradually, because reliable three-state devices were harder to build than two-state devices.\nHow to program using base 3 Now that we understand why base 3 numbering system might be a good choice for storing numbers, we need to introduce the ternary logic: how to add, subtract, multiply, and basically perform any operation a modern computer can perform.\nIn the next parts, we will talk exclusively about “balanced ternary” which is ternary digits or “trits” that can take values:\n-1 0 1 Those values can easily be mapped to boolean values according to the following table:\nTruth values Balanced ternary values Notations False -1 - Unknown 0 0 True 1 + A bit of logic Half-adder \u0026 full-adder When we want to perform any operation on numbers, whether they are binary numbers or ternary numbers, we first need to be able to perform those operations on single digit.\nThere are two different devices for the addition operation:\nthe half-adder: performs the operation on 2 digits the full-adder: performs the operation on 2 digits and the carry Addition, increment \u0026 decrement The first and simplest operation is the increment and decrement, which means adding 1 or subtracting 1 to any number. It is widely used even in high level programming languages:\nvariable += 1 To increment a number, we simply add 1 to the least significant digit, regardless of the base system. Let us look at what it means in ternary logic with the simple $5 + 1 = 6$ example. In ternary, the sum would look like this:\n$$ \\begin{matrix} \u0026 1 \u0026 {-1} \u0026 {-1} \\\\ + \u0026 0 \u0026 0 \u0026 1 \\\\ = \u0026 1 \u0026 {-1} \u0026 0 \\end{matrix} $$\nLet’s take a slightly more complex example, $7 + 1 = 8$, where the least significant trit will change because of the increment:\n$$ \\begin{matrix} \u0026 1 \u0026 {-1} \u0026 1 \\\\ + \u0026 0 \u0026 0 \u0026 1 \\\\ = \u0026 1 \u0026 0 \u0026 {-1} \\end{matrix} $$\nAs we can see, adding 1 to the least significant trit that is already 1 makes it goes to -1 which is exactly what we already do in base 10, when performing: $9 + 1 = 10$, the least significant digit becomes 0 (the lowest value a base 10 digit can take) and the next increases by 1.\nLikewise, if we need to decrement, we can just add $-1$ to the number. The logic is exactly the same, in reversed order.\nIn order to understand how we compute addition on a computer, let us define the half-adder and full-adder a bit more. When we perform the following addition:\n$$ 4 + 19 = 23 $$\nWe usually do it from right to left, from the least significant digits to the most significant digits. So we start with $9 + 4$ and it gives us two results:\nthe sum: the digit that will take place at the same position than the two digits we added together (here the least significant digit), it is the result of the sum of the two digits modulo the base value the carry: if the sum of the two digits is greater than the maximum value authorized by the base system we chose, we need to carry some information to the next digit, is it the result of the eulerian division of the sum of the two digits by the base value In our case, the sum is $(4 + 9) \\mod 10 = 3$ and the carry is $(4 + 9) // 10 = 1$.\nThe half-adder is the device that is able to compute those two values for each combination of trit addition:\na b sum carry - - + - - 0 - 0 - + 0 0 0 - - 0 0 0 0 0 0 + + 0 + - 0 0 + 0 + 0 + + - + We notice something interesting here, the carry is almost always equal to 0 except when a and b are equal, then it is equal to a and to b.\nThis specific operation is called consensus. It is possible to build a device that does only this and thus we will consider it an elementary operation as + or -.\nTo build a half-adder, here is the device we need: This is going to perform the two operations we talked about, computing the sum and the carry:\n$s_i = a_i + c_i$ in the notation of the picture (where $c_i$ is the carry of the previous operation, but it could also be the trit of another number we want to add) $c_{i + 1} = \\text{consensus}(a_i, c_i)$ Once we have a half-adder, we can use two of them to build a full-adder, which looks like this: As we can see on the picture, the first half-adder computes the intermediate sum $s_i$ and carry $c_a$ of the $a_i, b_i$ trits. The second half-adder computes the sum $s_i$ and carry $c_b$. In the end, the “anything” operation is used to combine both carries $c_a, c_b$. The anything operation returns 0 if both inputs are 0 or if they disagree (one is + and the other is -). It returns + or - if both inputs agree or if one is + or - and the other is 0.\nComparison When programming, we often a way to write conditional code, a code that will be executed only if certain conditions are met.\nIn order to do that, we need to be able to compare numbers. The elementary comparison is the comparison to 0, because if you need to compare two numbers $a, b$ you can just subtract $b$ from $a$ and compare the result to 0 to know which one is greater.\nIn binary, we would have a sign bit, a bit that is exclusively dedicated to indicate the sign of the number represented.\nIn balanced ternary, we encode negative numbers using the same system as positive numbers. The sign of the number is the sign of the most significant trit that is not 0.\nLet us see some examples:\n$-5 = - + +$ $2 = 0+-$ $6 = +-0$ In order to perform this operation, we need a device that is able to compare trits for the whole number representation. This is what it would look like for a 8-trit representation system. Each “X” component is a sign comparison. The truth table of such a component looks like this:\nSign comparison a0 - 0 + - - - - a1 0 - 0 + + + + + Here $a_0$ and $a_1$ are both trits that are being compared. $a_1$ is more significant than $a_0$. We notice that the sign of $a_1$ is chosen every time it is not 0. In this case, the sign of $a_0$ is chosen.\nThe meaning of the result is understood as follows:\n$+$ means $\u003e$ $0$ means $=$ $-$ means $\u003c$ The complexity of the comparison is $O(\\log n)$ with $n$ being the number of trits.\nMultiplication To conclude this part about logic, let us discuss the other main operation that we need to be able to perform when coding: multiplication.\nThere are two types of multiplication:\nmultiplication by a constant multiplication of two variables. For both operations, we will consider base 27. Why base 27? Because it corresponds to $27 = 3^3$ which is the number of values you can represent using 3 trits. In balanced ternary, we can store values from -13 to 13, which is 13 + 13 + 1 (zero) = 27 different values. It is the equivalent of base 16 (hexadecimal) in binary notation.\nWhen we want to multiply a variable by a constant in base 27, we need to be able to perform the multiplication for all numbers from -13 to 13, in balanced ternary. Let us show how we can perform some of those multiplications optimally:\n0: $a \\times 0 = 0$, the easiest one, obviously 1: $a \\times 1 = a$, also not too difficult 2: there are two ways of performing this operation: $a \\times 2 = a \\times 3 - a = a «_3 1 - a$ where $«_3$ is a trit shift to the left, so basically a shift and a subtraction $a \\times 2 = a + a$ which is an addition, that we already know how to do 3: because 3 corresponds to the base we are using, we can simply shift trits to the right (in the direction of the most significant trit) $a \\times 3 = a «_3 1$ 4: $a \\times 4 = a \\times 3 + a = a «_3 1 + a$ which is a shift and an addition 5: $a \\times 5 = a «_3 1 + 2 \\times a$ where we already solved $2 \\times a$ 6: $a \\times 6 = (a \\times 2) \\times 3 = (a \\times 2) «_3 1$ 7: $a \\times 7 = (a \\times 6) + a$ 8: could be done in two different ways $a \\times 8 = (a \\times 9) - a = (a «_3 2) - a$ but the subtraction might create what is called overflow, which is when the result needs more trits than the two input of the operation, it is a bit more complicated to detect it on a subtraction than on an addition $a \\times 8 = (a \\times 2) \\times 4$ where we know how to perform both multiplication already 9: $a \\times 9 = a «_3 2$ 10: $a \\times 10 = (a \\times 9) + a$ 11: $a \\times 11 = (a \\times 9) + (a \\times 2)$ where we know how to perform both operations already 12: $a \\times 12 = (a \\times 3) \\times 4$ 13: $a \\times 13 = (a \\times 9) + (a \\times 4)$ For negative constants, multiplying is basically multiplying by the same positive constant and reverse all trits, because $-21 = -(21) = - (+ - + 0) = - + - 0$.\nThe algorithm to multiply two variables requires a loop because we will compute multiple times a base 27 multiplication as we did with the constants.\nHere is the C code for the algorithm, as given by Douglas Jones in his goldmine blog:\nbalanced int times( balanced int a, balanced int b ) { unsigned int prod = 0; while (a != 0) { unsigned int p; /* the partial product */ switch (a ^ 0v0) { case -13: p = (b \u003c\u003c3 1) + b; p = (b \u003c\u003c3 2) + p; prod = (prod \u003c\u003c3 3) - p; break; case -12: p = (b \u003c\u003c3 1) + b; p = (p \u003c\u003c3 1); prod = (prod \u003c\u003c3 3) - p; break; ... case 12: p = (b \u003c\u003c3 1) + b; p = (p \u003c\u003c3 1); prod = (prod \u003c\u003c3 3) + p; break; case 13: p = (b \u003c\u003c3 1) + b; p = (b \u003c\u003c3 2) + p; prod = (prod \u003c\u003c3 3) + p; break; } a = a \u003e\u003e3 3; } return prod; } Where $«3$ in the code is the ternary shift operator.\nAs we can understand, we are sequencing the multiplication by 3-trit bloc, from the most significant bloc to the last.\nAdvantages We saw how to operate some basics operations of a ternary computing system. We now need to ask ourselves what advantages does it have compared to the binary system.\nIt has many, here are some of them:\nnegative numbers: as we saw, representing negative numbers is easy using balanced ternary because it doest not require having a sign trit, as in binary circuit complexity: the limiting factor in the number of transistors on a specific area is not the size of the transistors themselves but the circuits they require to be connected together. Increasing the number of transistors increases rapidly the circuit complexity. With ternary transistors, the same computing power would be reached using less transistors, allowing for more transistors per surface unit, even if ternary transistors might be larger than binary transistors theoretical optimum: as demonstrated at the beginning of this article, base 3 is closer to the theoretical optimum of the $rw$ product Conclusion As we saw during this article, the ternary system has some advantages over the binary system. It is closer to the optimum in terms of circuit complexity.\nUnfortunately for us, it is very likely that we will see ternary computers in the future. Not because it is unfeasible, but because it would require us to rewrite the whole tech stack modern computer science is based upon. From compilers to deep learning frameworks, we would have to adapt everything to ternary computers.\nOf course, it might not be impossible to create so-called ASIC (Application Specific Integrated Circuit) that would rely on ternary transistors, and allowing them to handle some of the processing.\nTo conclude, I recommend to anyone interested in ternary computing to read the very nice blog by Douglas Jones that I based some of my article from:\nDouglas W. Jones on Ternary Computing\n",
  "wordCount" : "3081",
  "inLanguage": "en",
  "datePublished": "2024-01-31T15:21:00+01:00",
  "dateModified": "2024-01-31T15:21:00+01:00",
  "author":{
    "@type": "Person",
    "name": "Julien Seveno"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://bornlex.github.io/posts/ternary-computing/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Julien's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://bornlex.github.io/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://bornlex.github.io/" accesskey="h" title="Home (Alt + H)">
                <img src="https://bornlex.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://bornlex.github.io/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://bornlex.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://bornlex.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Ternary Computing
    </h1>
    <div class="post-meta"><span title='2024-01-31 15:21:00 +0100 CET'>January 31, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3081 words&nbsp;·&nbsp;Julien Seveno&nbsp;|&nbsp;<a href="https://github.com/%3cpath_to_repo%3e/content/posts/ternary-computing.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> 
  <div class="post-content"><p><img loading="lazy" src="/ternary/ternary.jpeg" alt="Ternary"  />
</p>
<h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>First, let us define “computers” as any machine that can compute.</p>
<p>At first, analog machines were used. For example, electronic amplifiers can be used to perform integration, differentiation, root extraction, compute logarithm.</p>
<p>Analog computers played a significant role in history, but they have the disadvantage that noise can perturb the computation and lead to errors.</p>
<p>Digital computers later replaced analog ones and became mainstream. Any voltage within a range can be interpreted as a specific value. This makes digital computers much more resilient to errors.</p>
<h1 id="why-base-3">Why base 3?<a hidden class="anchor" aria-hidden="true" href="#why-base-3">#</a></h1>
<h2 id="what-is-a-numbering-system">What is a numbering system?<a hidden class="anchor" aria-hidden="true" href="#what-is-a-numbering-system">#</a></h2>
<p>Today, there are two numbering systems:</p>
<ul>
<li>decimal : used to represent numbers on a daily basis, count by hands</li>
<li>binary : used by a (very) large majority of computers</li>
</ul>
<p>The general formula to encode a number looks like this:
$$
x = \sum_{i = 0}^N d_i r^i
$$</p>
<p>Where:</p>
<ul>
<li>$d_i$ a factor for the $i\text{-th}$ power</li>
<li>$r$ is the base (for instance 2 for the binary system)</li>
</ul>
<p>Let us give some examples:</p>
<ul>
<li>in decimal (base 10), we read a number as follows:</li>
</ul>
<p>$$
19 = 1 * 10^1 + 9 * 10^0 = 10 + 9
$$</p>
<p>Here $r = 10$, $d_0 = 0$, $d_1 = 1$.</p>
<ul>
<li>in binary (base 2), the same number is represented as:</li>
</ul>
<p>$$
19 = 1 * 2^4 + 0 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 16 + 2 + 1 = 10011
$$</p>
<p>As we can see with those examples, the binary system uses more digits than the decimal system. But the decimal system needs to be able to produce 10 different values, instead of just two for the binary system.</p>
<p>We could ask ourselves what is the best, most efficient numbering system. But how do you measure the cost of a numeric representation?</p>
<h2 id="is-there-an-optimized-numbering-system">Is there an optimized numbering system?<a hidden class="anchor" aria-hidden="true" href="#is-there-an-optimized-numbering-system">#</a></h2>
<p>You cannot simply count digits, because then the bigger the numbering system the better. For example, you could represent 542,978 on a base 1,000,000 system. This way, you would have only 1 digit. But you would also have to recognize 1,000,000 different values for each digit, which might not be that easy, nor reliable.
On the other hand, nothing prevent you from using a base 1 system to store the value 542,978. You would only have to recognize if the digit value is 0 or 1, but you would need at least 542,978 digits to store the entire value, which does not seem very efficient.</p>
<p>By the way, this is why the base 2 system is convenient. It can represent any number using a relatively low numbers of digits, and recognizing if the value of the digit is 0 or 1 is easy, and components to build a computer using such a system are cheap.</p>
<p>What we understand is that there is a tradeoff between the number of digits to use to store values and the values that each of the digits can take. Let us give names to those two things:</p>
<ul>
<li>$r$ is the base, the number of values per digit</li>
<li>$w$ is the number of digits</li>
</ul>
<p>In order to optimize the numbering system, we want the base to be as low as possible as well as the number of digits to store a fixed value, for example 1,000,000. We can try to optimize the product of those two values:</p>
<p>$$
r^* = \argmin_{r, w} rw
$$</p>
<p>With keeping the following value constant (which represents the maximum value that can be stored):</p>
<p>$$
a = r^w
$$</p>
<p>We can rewrite the second equation as:</p>
<p>$$
w = \frac{\ln a}{\ln r}
$$</p>
<p>And use this value in the first equation:</p>
<p>$$
r^* = \argmin_{r, w} \text{ } rw \Leftrightarrow  \argmin_r \text{ } \ln a \frac{r}{\ln r}
$$</p>
<p>The term $\ln a$ is constant, so we can discard it, it won’t change the minimum of the expression:</p>
<p>$$
r^* = \argmin_r \frac{r}{\ln r}
$$</p>
<p>Which looks like this on a plot:
<img loading="lazy" src="/ternary/plot1.png" alt="Figure"  />
</p>
<p>The minimum of the function seems to reached between 2.5 and 3. The exact value is given by the following formula:</p>
<p>$$
r^* = \argmin_r \frac{r}{\ln r} \Leftrightarrow (\frac{r}{\ln r})&rsquo; = 0 \Leftrightarrow \frac{1}{\ln r} - \frac{1}{(\ln r)^2}
$$</p>
<p>$$
\frac{1}{\ln r} - \frac{1}{(\ln r)^2} \Leftrightarrow \frac{1}{\ln r} = \frac{1}{(\ln r)^2} \Leftrightarrow \ln r = (\ln r)^2
$$</p>
<p>Which is true for:</p>
<p>$$
\ln r = 1 \Leftrightarrow r = e \simeq 2.718
$$</p>
<p>Assuming that we need to represent numbers from 0 to 999,999 we can compute the product $rw$ for different base values:</p>
<ul>
<li>base 2 : $rw = 2 * \frac{\ln 999999}{\ln 2} \simeq 2 * 20 = 40$</li>
<li>base 10 : $rw = 10 * \frac{\ln 999999}{\ln 10} \simeq 10 * 6 = 60$</li>
<li>base $e$ : $rw = e * \frac{\ln 999999}{\ln e} \simeq e * 14 = 38.056$</li>
<li>base 3 : $rw = 3 * \frac{\ln 999999}{\ln 3} \simeq 3 * 13 = 39$</li>
</ul>
<p>$e \simeq 2.718$ is closer to three, which is confirmed by the value of the $rw$ product which is lower for base 3 than for base 2 or 10, making it the best system according to our hypothesis.</p>
<p>This is why at the early stages of computer science, the base 3 system attracted many computer designers.</p>
<!-- raw HTML omitted -->
<h2 id="history">History<a hidden class="anchor" aria-hidden="true" href="#history">#</a></h2>
<p>The first working ternary computer ever built was in USSR during the cold war. A few dozens machines were built, but the ternary system faded away gradually, because reliable three-state devices were harder to build than two-state devices.</p>
<h1 id="how-to-program-using-base-3">How to program using base 3<a hidden class="anchor" aria-hidden="true" href="#how-to-program-using-base-3">#</a></h1>
<p>Now that we understand why base 3 numbering system might be a good choice for storing numbers, we need to introduce the ternary logic: how to add, subtract, multiply, and basically perform any operation a modern computer can perform.</p>
<p>In the next parts, we will talk exclusively about “balanced ternary” which is ternary digits or “trits” that can take values:</p>
<ul>
<li>-1</li>
<li>0</li>
<li>1</li>
</ul>
<p>Those values can easily be mapped to boolean values according to the following table:</p>
<table>
<thead>
<tr>
<th>Truth values</th>
<th>Balanced ternary values</th>
<th>Notations</th>
</tr>
</thead>
<tbody>
<tr>
<td>False</td>
<td>-1</td>
<td>-</td>
</tr>
<tr>
<td>Unknown</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>True</td>
<td>1</td>
<td>+</td>
</tr>
</tbody>
</table>
<h2 id="a-bit-of-logic">A bit of logic<a hidden class="anchor" aria-hidden="true" href="#a-bit-of-logic">#</a></h2>
<h3 id="half-adder--full-adder">Half-adder &amp; full-adder<a hidden class="anchor" aria-hidden="true" href="#half-adder--full-adder">#</a></h3>
<p>When we want to perform any operation on numbers, whether they are binary numbers or ternary numbers, we first need to be able to perform those operations on single digit.</p>
<p>There are two different devices for the addition operation:</p>
<ul>
<li>the <strong>half-adder</strong>: performs the operation on 2 digits</li>
<li>the <strong>full-adder</strong>: performs the operation on 2 digits and the carry</li>
</ul>
<h3 id="addition-increment--decrement">Addition, increment &amp; decrement<a hidden class="anchor" aria-hidden="true" href="#addition-increment--decrement">#</a></h3>
<p>The first and simplest operation is the increment and decrement, which means adding 1 or subtracting 1 to any number. It is widely used even in high level programming languages:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">variable</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span></code></pre></div><p>To increment a number, we simply add 1 to the least significant digit, regardless of the base system. Let us look at what it means in ternary logic with the simple $5 + 1  = 6$ example. In ternary, the sum would look like this:</p>
<p>$$
\begin{matrix} &amp; 1 &amp; {-1} &amp; {-1} \\ + &amp; 0 &amp; 0 &amp; 1 \\ = &amp; 1 &amp; {-1} &amp; 0 \end{matrix}
$$</p>
<p>Let’s take a slightly more complex example, $7 + 1 = 8$, where the least significant trit will change because of the increment:</p>
<p>$$
\begin{matrix} &amp; 1 &amp; {-1} &amp; 1 \\ + &amp; 0 &amp; 0 &amp; 1 \\ = &amp; 1 &amp; 0 &amp; {-1} \end{matrix}
$$</p>
<p>As we can see, adding 1 to the least significant trit that is already 1 makes it goes to -1 which is exactly what we already do in base 10, when performing: $9 + 1 = 10$, the least significant digit becomes 0 (the lowest value a base 10 digit can take) and the next increases by 1.</p>
<p>Likewise, if we need to decrement, we can just add $-1$ to the number. The logic is exactly the same, in reversed order.</p>
<p>In order to understand how we compute addition on a computer, let us define the half-adder and full-adder a bit more. When we perform the following addition:</p>
<p>$$
4 + 19 = 23
$$</p>
<p>We usually do it from right to left, from the least significant digits to the most significant digits. So we start with $9 + 4$ and it gives us two results:</p>
<ul>
<li><strong>the sum</strong>: the digit that will take place at the same position than the two digits we added together (here the least significant digit), it is the result of the sum of the two digits modulo the base value</li>
<li><strong>the carry</strong>: if the sum of the two digits is greater than the maximum value authorized by the base system we chose, we need to carry some information to the next digit, is it the result of the eulerian division of the sum of the two digits by the base value</li>
</ul>
<p>In our case, the sum is $(4 + 9) \mod 10 = 3$ and the carry is $(4 + 9) // 10 = 1$.</p>
<p>The half-adder is the device that is able to compute those two values for each combination of trit addition:</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>sum</th>
<th>carry</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>-</td>
<td>+</td>
<td>-</td>
</tr>
<tr>
<td>-</td>
<td>0</td>
<td>-</td>
<td>0</td>
</tr>
<tr>
<td>-</td>
<td>+</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>-</td>
<td>-</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>+</td>
<td>+</td>
<td>0</td>
</tr>
<tr>
<td>+</td>
<td>-</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>+</td>
<td>0</td>
<td>+</td>
<td>0</td>
</tr>
<tr>
<td>+</td>
<td>+</td>
<td>-</td>
<td>+</td>
</tr>
</tbody>
</table>
<p>We notice something interesting here, the carry is almost always equal to 0 except when a and b are equal, then it is equal to a and to b.</p>
<p>This specific operation is called <strong>consensus</strong>. It is possible to build a device that does only this and thus we will consider it an elementary operation as + or -.</p>
<p>To build a half-adder, here is the device we need:
<img loading="lazy" src="/ternary/half-adder.png" alt="Picture of the half-adder"  />
</p>
<p>This is going to perform the two operations we talked about, computing the sum and the carry:</p>
<ul>
<li>$s_i = a_i + c_i$ in the notation of the picture (where $c_i$ is the carry of the previous operation, but it could also be the trit of another number we want to add)</li>
<li>$c_{i + 1} = \text{consensus}(a_i, c_i)$</li>
</ul>
<p>Once we have a half-adder, we can use two of them to build a full-adder, which looks like this:
<img loading="lazy" src="/ternary/full-adder.png" alt="Picture of the full-adder"  />
</p>
<p>As we can see on the picture, the first half-adder computes the intermediate sum $s_i$ and carry $c_a$ of the $a_i, b_i$ trits. The second half-adder computes the sum $s_i$ and carry $c_b$. In the end, the “anything” operation is used to combine both carries $c_a, c_b$.
The anything operation returns 0 if both inputs are 0 or if they disagree (one is + and the other is -). It returns + or - if both inputs agree or if one is + or - and the other is 0.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="comparison">Comparison<a hidden class="anchor" aria-hidden="true" href="#comparison">#</a></h3>
<p>When programming, we often a way to write conditional code, a code that will be executed only if certain conditions are met.</p>
<p>In order to do that, we need to be able to compare numbers. The elementary comparison is the comparison to 0, because if you need to compare two numbers $a, b$ you can just subtract $b$ from $a$ and compare the result to 0 to know which one is greater.</p>
<p>In binary, we would have a sign bit, a bit that is exclusively dedicated to indicate the sign of the number represented.</p>
<p>In balanced ternary, we encode negative numbers using the same system as positive numbers. The sign of the number is the sign of the most significant trit that is not 0.</p>
<p>Let us see some examples:</p>
<ul>
<li>$-5 = - + +$</li>
<li>$2 = 0+-$</li>
<li>$6 = +-0$</li>
</ul>
<p>In order to perform this operation, we need a device that is able to compare trits for the whole number representation. This is what it would look like for a 8-trit representation system.
<img loading="lazy" src="/ternary/comparison.png" alt="Comparison"  />
</p>
<p>Each “X” component is a sign comparison. The truth table of such a component looks like this:</p>
<table>
<thead>
<tr>
<th>Sign comparison</th>
<th></th>
<th></th>
<th>a0</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>-</td>
<td>0</td>
<td>+</td>
</tr>
<tr>
<td></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>a1</td>
<td>0</td>
<td>-</td>
<td>0</td>
<td>+</td>
</tr>
<tr>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
</tbody>
</table>
<p>Here $a_0$ and $a_1$ are both trits that are being compared. $a_1$ is more significant than $a_0$. We notice that the sign of $a_1$ is chosen every time it is not 0. In this case, the sign of $a_0$ is chosen.</p>
<p>The meaning of the result is understood as follows:</p>
<ul>
<li>$+$ means $&gt;$</li>
<li>$0$ means $=$</li>
<li>$-$ means $&lt;$</li>
</ul>
<p>The complexity of the comparison is $O(\log n)$ with $n$ being the number of trits.</p>
<h3 id="multiplication">Multiplication<a hidden class="anchor" aria-hidden="true" href="#multiplication">#</a></h3>
<p>To conclude this part about logic, let us discuss the other main operation that we need to be able to perform when coding: multiplication.</p>
<p>There are two types of multiplication:</p>
<ul>
<li>multiplication by a constant</li>
<li>multiplication of two variables.</li>
</ul>
<p>For both operations, we will consider base 27. Why base 27? Because it corresponds to $27 = 3^3$ which is the number of values you can represent using 3 trits. In balanced ternary, we can store values from -13 to 13, which is 13 + 13 + 1 (zero) = 27 different values.
It is the equivalent of base 16 (hexadecimal) in binary notation.</p>
<p>When we want to multiply a variable by a constant in base 27, we need to be able to perform the multiplication for all numbers from -13 to 13, in balanced ternary. Let us show how we can perform some of those multiplications optimally:</p>
<ul>
<li>0: $a \times 0 = 0$, the easiest one, obviously</li>
<li>1: $a \times 1 = a$, also not too difficult</li>
<li>2: there are two ways of performing this operation:
<ul>
<li>$a \times 2 = a \times 3 - a = a &laquo;_3 1 - a$ where $&laquo;_3$ is a trit shift to the left, so basically a shift and a subtraction</li>
<li>$a \times 2 = a + a$ which is an addition, that we already know how to do</li>
</ul>
</li>
<li>3: because 3 corresponds to the base we are using, we can simply shift trits to the right (in the direction of the most significant trit) $a \times 3 = a &laquo;_3 1$</li>
<li>4: $a \times 4 = a \times 3 + a = a &laquo;_3 1 + a$ which is a shift and an addition</li>
<li>5: $a \times 5 = a &laquo;_3 1 + 2 \times a$ where we already solved $2 \times a$</li>
<li>6: $a \times 6 = (a \times 2) \times 3 = (a \times 2) &laquo;_3 1$</li>
<li>7: $a \times 7 = (a \times 6) + a$</li>
<li>8: could be done in two different ways
<ul>
<li>$a \times 8 = (a \times 9) - a = (a &laquo;_3 2) - a$ but the subtraction might create what is called overflow, which is when the result needs more trits than the two input of the operation, it is a bit more complicated to detect it on a subtraction than on an addition</li>
<li>$a \times 8 = (a \times 2) \times 4$ where we know how to perform both multiplication already</li>
</ul>
</li>
<li>9: $a \times 9 = a &laquo;_3 2$</li>
<li>10: $a \times 10 = (a \times 9) + a$</li>
<li>11: $a \times 11 = (a \times 9) + (a \times 2)$ where we know how to perform both operations already</li>
<li>12: $a \times 12 = (a \times 3) \times 4$</li>
<li>13: $a \times 13 = (a \times 9) + (a \times 4)$</li>
</ul>
<p>For negative constants, multiplying is basically multiplying by the same positive constant and reverse all trits, because $-21 = -(21) = - (+ - + 0) = - + - 0$.</p>
<p>The algorithm to multiply two variables requires a loop because we will compute multiple times a base 27 multiplication as we did with the constants.</p>
<p>Here is the C code for the algorithm, as given by Douglas Jones in his <a href="https://homepage.cs.uiowa.edu/~dwjones/ternary/multiply.shtml">goldmine blog</a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">balanced</span> <span class="kt">int</span> <span class="nf">times</span><span class="p">(</span> <span class="n">balanced</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">balanced</span> <span class="kt">int</span> <span class="n">b</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prod</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p</span><span class="p">;</span> <span class="cm">/* the partial product */</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="p">(</span><span class="n">a</span> <span class="o">^</span> <span class="mi">0</span><span class="n">v0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="o">-</span><span class="mi">13</span><span class="o">:</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                      <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                      <span class="n">prod</span> <span class="o">=</span> <span class="p">(</span><span class="n">prod</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="o">-</span><span class="mi">12</span><span class="o">:</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                      <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                      <span class="n">prod</span> <span class="o">=</span> <span class="p">(</span><span class="n">prod</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">               <span class="p">...</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span>  <span class="mi">12</span><span class="o">:</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                      <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                      <span class="n">prod</span> <span class="o">=</span> <span class="p">(</span><span class="n">prod</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span>  <span class="mi">13</span><span class="o">:</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                      <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                      <span class="n">prod</span> <span class="o">=</span> <span class="p">(</span><span class="n">prod</span> <span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&gt;&gt;</span><span class="mi">3</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Where $&laquo;3$ in the code is the ternary shift operator.</p>
<p>As we can understand, we are sequencing the multiplication by 3-trit bloc, from the most significant bloc to the last.</p>
<h1 id="advantages">Advantages<a hidden class="anchor" aria-hidden="true" href="#advantages">#</a></h1>
<p>We saw how to operate some basics operations of a ternary computing system. We now need to ask ourselves what advantages does it have compared to the binary system.</p>
<p>It has many, here are some of them:</p>
<ul>
<li><strong>negative numbers</strong>: as we saw, representing negative numbers is easy using balanced ternary because it doest not require having a sign trit, as in binary</li>
<li><strong>circuit complexity</strong>: the limiting factor in the number of transistors on a specific area is not the size of the transistors themselves but the circuits they require to be connected together. Increasing the number of transistors increases rapidly the circuit complexity. With ternary transistors, the same computing power would be reached using less transistors, allowing for more transistors per surface unit, even if ternary transistors might be larger than binary transistors</li>
<li><strong>theoretical optimum</strong>: as demonstrated at the beginning of this article, base 3 is closer to the theoretical optimum of the $rw$ product</li>
</ul>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>As we saw during this article, the ternary system has some advantages over the binary system. It is closer to the optimum in terms of circuit complexity.</p>
<p>Unfortunately for us, it is very likely that we will see ternary computers in the future. Not because it is unfeasible, but because it would require us to rewrite the whole tech stack modern computer science is based upon. From compilers to deep learning frameworks, we would have to adapt everything to ternary computers.</p>
<p>Of course, it might not be impossible to create so-called ASIC (Application Specific Integrated Circuit) that would rely on ternary transistors, and allowing them to handle some of the processing.</p>
<p>To conclude, I recommend to anyone interested in ternary computing to read the very nice blog by Douglas Jones that I based some of my article from:</p>
<p><a href="https://homepage.cs.uiowa.edu/~dwjones/ternary/">Douglas W. Jones on Ternary Computing</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://bornlex.github.io/posts/vendeurs-plage/">
    <span class="title">« Prev</span>
    <br>
    <span>Le problème des vendeurs de plage</span>
  </a>
  <a class="next" href="https://bornlex.github.io/posts/2018-10-14-code-injection/">
    <span class="title">Next »</span>
    <br>
    <span>Code injection</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Ternary Computing on x"
            href="https://x.com/intent/tweet/?text=Ternary%20Computing&amp;url=https%3a%2f%2fbornlex.github.io%2fposts%2fternary-computing%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Ternary Computing on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fbornlex.github.io%2fposts%2fternary-computing%2f&amp;title=Ternary%20Computing&amp;summary=Ternary%20Computing&amp;source=https%3a%2f%2fbornlex.github.io%2fposts%2fternary-computing%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Ternary Computing on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fbornlex.github.io%2fposts%2fternary-computing%2f&title=Ternary%20Computing">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Ternary Computing on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbornlex.github.io%2fposts%2fternary-computing%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Ternary Computing on whatsapp"
            href="https://api.whatsapp.com/send?text=Ternary%20Computing%20-%20https%3a%2f%2fbornlex.github.io%2fposts%2fternary-computing%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Ternary Computing on telegram"
            href="https://telegram.me/share/url?text=Ternary%20Computing&amp;url=https%3a%2f%2fbornlex.github.io%2fposts%2fternary-computing%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Ternary Computing on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Ternary%20Computing&u=https%3a%2f%2fbornlex.github.io%2fposts%2fternary-computing%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://bornlex.github.io/">Julien&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
